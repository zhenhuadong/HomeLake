
# 1. java AOP的原理是什么？




# 2. Java AOP有几种实现？
AOP 有两种典型framework：
- AspectJ
  - 编译时
    - 静态AOP（AspectJ）：编译时进行增强，切面直接以字节码的形式编译到目标字节码文件中。需要专有的编译器和织入器。
      - 优点：被织入的类性能不受影响。
      - 缺点：不够灵活
- Spring AOP (w/o annotation)
  - 运行时
    - 对作用在interface方法上的的切片使用JDK动态代理
      - 动态AOP(JDK动态代理)：在运行期，目标类加载后，为接口动态生成代理类，将切面植入到代理类中。在运行时动态织入AOP，使用反射执行织入的逻辑。 主要实现方式依赖java.lang.reflect包下的InvocationHandler和Proxy类。
        - 优点：Java标准库原生支持，使用简单，无需引用额外的包。相对于静态AOP更灵活。
        - 缺点：带代理的类必须是接口，灵活性受到一些限制；使用反射会影响一些性能
    - 对作用在非interface方法上的切片使用CGLib动态生成代码字节
      - 动态代码字节生成（CGLib）：在运行期，目标类加载后，动态构建字节码文件生成目标类的子类，将切面逻辑加入到子类中。
CGLib是动态代码字节生成的实现，它封装字节码生成工具Asm，原理是在运行期间目标字节码加载后，生成目标类的子类，将切面逻辑加入到子类中，所以使用Cglib实现AOP不需要基于接口。
        - 优点：没有接口也可以织入，灵活性高。
        - 缺点：扩展类的实例方法为final时，则无法进行织入

